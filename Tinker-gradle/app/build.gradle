apply plugin: 'com.android.application'

def javaVersion = JavaVersion.VERSION_1_7
//buildDir代表app这个module下的build文件夹，如果创建成功会在build下再创建一个bakApk文件夹
def bakPath = file("${buildDir}/bakApk/") //指定基准文件存放位置

android {
    compileSdkVersion 25
    buildToolsVersion "25.0.3"
    defaultConfig {
        applicationId "com.kenny.tinker"
        minSdkVersion 15
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        multiDexEnabled true
    }

    sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
        }
    }

    compileOptions {
        sourceCompatibility javaVersion
        targetCompatibility javaVersion
    }
    //recommend
    dexOptions {
        jumboMode = true
    }

    signingConfigs {
        release {
            try {
                storeFile file("release.keystore")
                storePassword "testres"
                keyAlias "testres"
                keyPassword "testres"
            } catch (ex) {
                throw new InvalidUserDataException(ex.toString())
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    //真正的多渠道脚本支持
    productFlavors {

        googleplayer {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "googleplayer"]
        }

        baidu {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "baidu"]
        }

        productFlavors.all {
            flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:25.1.1'
    testCompile 'junit:junit:4.12'

    //可选，用于生成application类,        provided只参与编译不参与打包
    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
    //tinker的核心库，                   compile参与编译并会打包到apk中
    compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
    //让应用支持多dex文件
    compile "com.android.support:multidex:1.0.1"

    compile 'com.squareup.okhttp3:okhttp:3.3.0' //okttp依赖
//
//    compile 'de.hdodenhof:circleimageview:2.1.0'
//    compile 'com.readystatesoftware.systembartint:systembartint:1.0.3'
}

ext {
    //代表启动tinker，也是tinker启用的开关
    tinkerEnable = true
    //old的apk存放路径
    tinkerOldApkPath = "${bakPath}/app-0808-11-59-06"
    //old apk打包时所使用的混淆文件路径
    tinkerApplyMappingPath = "${bakPath}/app-0808-11-59-06"
    //old apk的资源文件
    tinkerApplyResourcePath = "${bakPath}/app-0808-11-59-06"
    //tinkerID
    tinkerID = "1.0"
    tinkerBuildFlavorDirectory = "${bakPath}/app-0808-11-59-06"
}

//判断是否使用了tinker的方法
def buildWithTinker() {

    return ext.tinkerEnable
}

//获取oldApk存放地址的方法
def getOldApkPath() {

    return ext.tinkerOldApkPath
}

//指定old apk打包时所使用的混淆文件的方法
def getApplyMappingPath() {
    return ext.tinkerApplyMappingPath
}

//指定old apk的资源文件的方法
def getApplyResourceMappingPath() {
    return ext.tinkerApplyResourcePath
}

//获取tinkerId
def getTinkerIdValue() {
    return ext.tinkerID
}
//多渠道路径
def getTinkerBuildFlavorDirectory(){

    return ext.tinkerBuildFlavorDirectory
}

if (buildWithTinker()) {
    //启用tinker
    apply plugin: 'com.tencent.tinker.patch'

    //所有tinker相关的参数配置
    tinkerPatch {

        oldApk = getOldApkPath() //指定old的apk存放路径

        ignoreWarning = false   //不忽略tinker的警告，有则中止patch文件的生成

        useSign = true  //强制patch文件也使用签名，防止patch文件被创改

        tinkerEnable = buildWithTinker(); //指定是否启用tinker

        buildConfig {

            applyMapping = getApplyMappingPath()  //指定old apk打包时所使用的混淆文件

            applyResourceMapping = getApplyResourceMappingPath()  //指定old apk的资源文件

            tinkerId = getTinkerIdValue() //指定tinkerId，每个patch文件的唯一标识符，它必须与我们的apk一致才能打到old的apk中

            keepDexApply = false //这个参数是在apk使用了MultiDex的时候做的一些操作，实际开发中置为false就行，如果置为true则会在生成patch的时候会根据dex文件的分包去动态的编译patch
        }

        dex {

            /*
             指定dex的模式，tinker提供了两种模式：jar、raw
             区别：jar模式适配了API14以下使用，raw模式适配API14以上使用
             jar模式：tinker在处理dex文件的时候会将dex重新压缩成jar文件，然后对jar文件进行处理
             raw模式：表明tinker直接对dex文件做处理
             使用jar文件在生成patch文件的时候体积会小一些，所以通常使用jar模式
            */
            dexMode = "jar"
            //指定tinker要处理的dex文件都在哪此目录-->apk文件中的classes.dex
            pattern = ["classes*.dex", "assets/secondary-dex-?.jar"]
            //指定加载patch文件时用到的类
            loader = ["com.kenny.tinker.tinkermanager.MyTinkerApplication"]
        }

        lib {
            //由于tinker也可以替换.so架包，所以给它指明工程的架包放置地址
            pattern = ["libs/*/*.so"]
        }

        res {
            //指定tinker可以修改的所有资源文件路径
            pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
            //指定tinker可以修改的资源路径
            //指定不受影响的资源路径,即使修改了这部分文件，tinker也不会将资源打到apk中去     sample_meta.txt测试文件而已
            ignoreChange = ["assets/sample_meta.txt"]
            //如果资源修改超过了100k，tinker会使用bsdiff算法来减少patch文件的体积
            largeModSize = 100 //资源修改大小默认值
        }

        packageConfig {
            //说明本次patch文件的信息
            configField("patchMessage", "fix the 1.0 version's bugs")
            //本次patch的版本号，如果又有新的发布则往此值中逐增，如1.1   1.2
            configField("patchVersion", "1.0")
        }
    }

    //为了节省步骤我们将打包apk的过程使用脚本的方式来实现，每次生成apk/patch等都放到指定目录中
    /**------------------------------------脚本begin---------------------------------------------*/
    List<String> flavors = new ArrayList<>();
    project.android.productFlavors.each { flavor ->
        flavors.add(flavor.name)
    }
    boolean hasFlavors = flavors.size() > 0
    /**
     * 复制基准包和其它必须文件到指定目录
     */
    android.applicationVariants.all { variant ->
        /**
         * task type, you want to bak
         */
        def taskName = variant.name
        def date = new Date().format("MMdd-HH-mm-ss")

        tasks.all {
            if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {

                it.doLast {
                    copy {
                        def fileNamePrefix = "${project.name}-${variant.baseName}"
                        def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"

                        def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
                        from variant.outputs.outputFile
                        into destPath
                        rename { String fileName ->
                            fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
                        }

                        from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("mapping.txt", "${newFileNamePrefix}-mapping.txt")
                        }

                        from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
                        into destPath
                        rename { String fileName ->
                            fileName.replace("R.txt", "${newFileNamePrefix}-R.txt")
                        }
                    }
                }
            }
        }
    }


    project.afterEvaluate {
        //多渠道脚本，此处判断是否有多渠道，有则执行下面这段
        if (hasFlavors) {
            //生成所有release的patch文件
            task(tinkerPatchAllFlavorRelease) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Release")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}ReleaseManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-release-R.txt"
                    }
                }
            }
            //生成所有debug的patch文件
            task(tinkerPatchAllFlavorDebug) {
                group = 'tinker'
                def originOldPath = getTinkerBuildFlavorDirectory()
                for (String flavor : flavors) {
                    def tinkerTask = tasks.getByName("tinkerPatch${flavor.capitalize()}Debug")
                    dependsOn tinkerTask
                    def preAssembleTask = tasks.getByName("process${flavor.capitalize()}DebugManifest")
                    preAssembleTask.doFirst {
                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)
                        project.tinkerPatch.oldApk = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug.apk"
                        project.tinkerPatch.buildConfig.applyMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-mapping.txt"
                        project.tinkerPatch.buildConfig.applyResourceMapping = "${originOldPath}/${flavorName}/${project.name}-${flavorName}-debug-R.txt"
                    }

                }
            }
        }
    }
    /**------------------------------------脚本end---------------------------------------------*/
}



